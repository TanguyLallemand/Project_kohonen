# Author: Tanguy Lallemand

###############################################################################
# Setup argument parser
###############################################################################
arg_parser<-function()
{
    option_list <- list(
        make_option(c("-v", "--verbose"), action="store_true", default=TRUE,
                    help="Activate verbosity of this script"),
        make_option(c("-r", "--rate"), action="store_true", type="numeric", default=0.75,
                    help="Give a different initial learn rate"),
        make_option(c("-t", "--radius"), action="store_true", type="numeric", default=2.0,
                    help="Give a different initial learn radius"),
        make_option(c("-n", "--number_iteration"), action="store_true", type="integer", default=2, 
                    help="Give a particular number of iterations")
     ); 
  opt_parser = OptionParser(option_list=option_list);
  opt = parse_args(opt_parser);
  return(opt)
}


###############################################################################
# If argument for verbosity has been passed this function will display current 
# configuration
###############################################################################
verbose<-function(learn_rate_at_initialization, initial_radius, number_max_iteration)
{
    print("############Configuration used:############")
    print(paste("Initial learning rate : ",learn_rate_at_initialization, sep=""))
    print(paste("Initial radius: ",initial_radius, sep=""))
    print(paste("Number of iterations: ", number_max_iteration, sep=""))
    print("###########################################")
}


###############################################################################
# Generate a random dataset composed by vector of 8 random values, 
# saved in a list
###############################################################################
generate_a_random_dataset_function<-function()
{
    list_of_random_vector<-list()
    for (iterator in 1:number_of_neurons)
    {
        # Generate a vector of eight values
        vector_random <- round(runif(8, min=-180, max=180), digits=0)
        # Save it in a list
        list_of_random_vector[iterator]<-list(vector_random)
    }
    return(list_of_random_vector)
}


###############################################################################
# Generate all possible compilation using number of neurons, allows to 
# access to cells of Kohonen map using this set of index generated by this 
# function
###############################################################################
generate_all_possible_combinations<-function(number_of_neurons)
{
    neuron_label<-list()
    count = 1
    for (x in 1:sqrt(number_of_neurons)) 
    {
        for (y in 1:sqrt(number_of_neurons)) 
        {
            neuron_label[[count]] = c(x,y)
            count = count +1
        }
    }
    return(neuron_label)
}


###############################################################################
# Calculate rmsd distance between a vector of training dataset and all neurons 
# of kohonen map, it will return index of the closest neuron to current row
# from dataset
###############################################################################
rmsd_function<-function(training_dataset_for_block_a, kohonen_matrix)
{
    rms<-0
    best_cell <- 0
    count = 1
    for (x in 1:4)
    {
        for (y in 1:4) 
        { 
            difference <- as.numeric(unlist(training_dataset_for_block_a))-as.numeric(unlist(kohonen_matrix[x,y]))
            rmsd <- sqrt(mean(unlist(difference)^2))
            if(count==1)
            {
                highest_rmsd <- rmsd
                # Save position of best neuron
                best_cell <- c(x,y)
            }
            else if(highest_rmsd > rmsd)
            {
                temp_neuron <- vector()
                highest_rmsd <- rmsd
                #efine the best neuron
                best_cell <- c(x,y)
            }
        }
    }
    return(best_cell)
}


###############################################################################
# Learning fuction for kohonen algorithm
###############################################################################
learning_function<-function(init_rate,current_iteration,phipsi_angles)
{
    return(init_rate/(1+(current_iteration/nrow(phipsi_angles))))
}


###############################################################################
# Construct a plot using kohonen map
# Save it in png using contructed filename
###############################################################################
construct_and_save_plots <- function(number_of_neurons, kohonen_matrix, filename)
{
    list_of_plot <- list()
    count_iterations <- 0
    # We go through all columns
    for(i in 1:sqrt(number_of_neurons))
    {
        # We go through all rows
        for(j in 1:sqrt(number_of_neurons))
        {
            # Save current iteration
            count_iterations <- count_iterations+1
            # Get one cell of kohonen matrix
            cell_of_kohonen_matrix<-unlist(kohonen_matrix[i,j])
            # Construct a graph of this cell
            ggplot <- ggplot() + 
                aes(x=seq_along(cell_of_kohonen_matrix), y=cell_of_kohonen_matrix) +
                geom_line(colour="#0072B2")  + geom_hline(yintercept=0, linetype="dashed", color = "red") + 
                ylim(-180, 180) +
                theme(axis.title.x=element_blank(),
                      axis.text.x=element_blank(),
                      axis.ticks.x=element_blank(),
                      axis.title.y=element_blank(),
                      axis.text.y=element_blank(),
                      axis.ticks.y=element_blank())
            # Save this graph in a list of plot
            list_of_plot[[count_iterations]] <- ggplotGrob(ggplot)
        }
    }
    # Construct a figure gathering all plots
    multiple_graph <- grid.arrange(grobs=list_of_plot, ncol=sqrt(number_of_neurons), nrow=sqrt(number_of_neurons))
    # Save it in pdf
    ggsave(filename=paste(filename,".png", sep = ""), plot=multiple_graph)
}
